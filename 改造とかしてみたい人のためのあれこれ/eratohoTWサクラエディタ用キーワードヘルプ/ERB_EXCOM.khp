;キーワードヘルプファイル
;-------------------------------------------------------------------------------------------------------
;erabasic文法
;-------------------------------------------------------------------------------------------------------
;=======================================================================================================
;excom(基本的にEmuera Wikiの丸パクリ)
;=======================================================================================================

;PRINT系
PRINT,PRINTV,PRINTS,PRINTL,PRINTW,PRINTFORM,PRINTFORMV,PRINTFORMS,PRINTFORML,PRINTFORMW /// PRINT(|V|S|FORM|FORMS)(|K|D)(|L|W)\nPRINT系の基本となる命令です。\n1つ目の括弧内のキーワードは引数タイプを指定します。\n\n    なし - (<文字列>)\n    V - (<数式> <数式> ,<数式> ……)\n    S - <文字列式>\n    FORM - (<書式付文字列>)\n    FORMS - <書式付文字列式> \n\n2つ目の括弧内のキーワードの"K"はFORCEKANA命令の適用を指定します。またキーワード"D"はSETCOLOR命令を無視することを指定します。ver1.736現在、キーワードKとDを同時に指定することはできません。\n\n    なし - FORCEKANAを無視し、SETCOLORで指定された色で描画します。\n    K - FORCEKANAを適用して描画します。\n    D - SETCOLORを無視してコンフィグで指定されたディフォルト色で描画します。 \n\n3つ目の括弧内のキーワードは描画後の改行、WAITの有無を指定します。\n\n    なし - PRINTのみで改行やWAITは行いません。\n    L - PRINT後、改行します。\n    W - PRINT後、改行しWAIT命令を行います。 \n\nこれらの組み合わせにより、例えばPRINTSDWであれば、引数として<文字列式>を指定し、ディフォルト色で描画し、PRINT後にWAIT命令を行うことを意味します。 
PRINTSINGLE /// PRINTSINGLE(|V|S|FORM|FORMS)(|K|D)\nPRINTSINGLE系はPRINTLとほぼ同じですが、PRINTSINGLE系は文字列を折り返さず、必ず1行で表示します。\n画面端を超えた文字は描画されません。\nまた、自動的に改行が付与されるため、(|L|W)キーワードはありません。\n他のキーワードの意味はPRINT系と同じです。 
PRINTC /// PRINT(|FORM)(C|LC)(|K|D)\nPRINTC系命令です。\nコンフィグ"PRINTCの文字数"（初期値25）で指定した文字数になるように半角スペースを補ってPRINTする命令です。\nなお、EmueraではPRINTされた文字列のボタン化処理の中でPRINTC系命令を多少特別扱いしています。\n1つ目の括弧内のキーワードは引数タイプを指定します。\n\n    なし - <文字列>\n    FORM - <書式付文字列> \n\n2つ目の括弧内のキーワードは揃える位置を指定します。\n\n    C - 右に揃えます（左側に半角スペースを追加します）\n    LC - 左に揃えます。 \n\n3つ目の括弧内のK,DはPRINT系と同じです。 
PRINTDATA /// PRINTDATA(|K|D)(|L|W)\nPRINTDATA系命令です。 私家改造版readmeによれば、\n\n　書式：PRINTDATA (数値変数：省略可)\n　　　　　DATA (文字)\n　　　　　DATAFORM (FORM文字列)\n　　　　　DATALIST\n　　　　　　(DATA or DATAFORMの羅列)\n　　　　　ENDLIST\n　　　　ENDDATA\n　内容：DATA、DATAFORMおよびDATALIST～ENDLISTで指定した文字列を確率均一でランダムで表示\n　　　　IFとRANDを使わずにランダム表示を実装可能\n　　　　引数に数値変数を指定した場合は表示された変数DATAの番号が入ります\n　　　　表示された文字列によって後の処理をいじりたい場合にどうぞ\n　　　　DATALIST～ENDLIST内ではDATAorDATAFORM1個が1行に相当します\n\nとのことです。\nK、D、L、Wキーワードの効果はPRINT系と同じです。\nPRINTDATA系～ENDDATAの内部にDATA系による表示データが与えられてない場合、何もせずに次に進みます。\nPRINTDATA系～ENDDATA、およびDATALIST～ENDLIST内に上記の文法以外の記述をすることはできません。
PRINTBUTTON /// PRINTBUTTON(|C|LC) <文字列式>, <数式 or 文字列式>\nPRINTBUTTON命令はマウスでクリックできるボタンを生成するための命令です。\n書式としてはPRINTS命令に近いですが、第二引数としてクリックされたときに入力する数字または文字を指定します。 第一引数に改行コードが入っている場合オミットされ改行されません。\n\nEmueraは"[300] セーブ"のように[]でくくられた数字とその前後の文字列を自動的にボタンに変換します。\nこのようなボタンを自動ではなく強制的に生成するための命令がPRINTBUTTONです。\nこの命令は例えば以下のような場合に有用です。\n\nPRINT これでいい？ [0] はい    [1] いいえ\nINPUT\n\nこのような行についてはEmueraはボタンを正しく認識できず、"これでいい？ [0] はい"というボタンと"[1] いいえ"というボタンになってしまいます。\nPRINTBUTTONを用いて書き直すと以下のようになります。\n\nPRINTS "これでいい？ "\nPRINTBUTTON "[0] はい", 0\nPRINTS "     "\nPRINTBUTTON "[1] いいえ", 1\nINPUT\n\n（PRINT命令の代わりにPRINTSを使っていますがこれは半角スペースの数を明らかにするためです）\nこのようにすると"これでいい？ "はボタンではなくなり、"[0] はい"と"[1] いいえ"だけがボタンになります。\nなお、PRITNBUTTON命令では表示する文字列に[0]や[1]などが含まれていることは必須ではありませんが、対応する数字を全く表示しないとテンキーなどで操作している方を戸惑わせることになるでしょう。 従来通り[0]などを表記することを勧めます。\n\nまた、PRINTBUTTON命令では数字だけでなく文字列を入力するボタンを作成することができます。 そうして作成したボタンはINPUTS命令の実行時にクリックすることができます。\n\nPRINTL 名前を入力してください。\nPRINTBUTTON "[ほげほげ] ", "ほげほげ"\nPRINTBUTTON "[ぷげぷげ] ", "ぷげぷげ"\nPRINTBUTTON "[ふうばあ] ", "ふうばあ"\nINPUTS\n\n括弧内のキーワードは文字を揃える位置を指定します。\n\n    なし - 揃えません\n    C - PRINTCと同様に右側に揃えます\n    LC - PRINTLCと左に揃えます 
PRINTPLAIN /// PRINTPLAIN(|FORM)\n引数の文字列を平文として出力します。この時ボタン文字列（0など）があってもボタン化しません。\n括弧内のキーワードは引数タイプを指定します。\n\n    なし - <文字列>\n    FORM - <書式付文字列> 
CUSTOMDRAWLINE,DRAWLINEFORM /// CUSTOMDRAWLINE <文字列>\nDRAWLINEFORM <FORM文字列>\n指定した文字列を使って1行の区切りを表示します。 DRAWLINEFORMではFORM構文に対応しています。 
REUSELASTLINE /// REUSELASTLINE <書式付文字列>\n最終行を指定した書式付き文字列で書き換えるが、\nこれを使って書き換えた行は、次の行が追加されるとそれに置き換わる\n基本的にはINPUT、INPUTSのループ処理の中でのみ使用するもの\n引数はPRINTFORMと同様の書式を使用可\nなお、REUSELASTLINE （この半角スペース必須）とすれば、警告文なしで空行にできます\n\n　　$INPUT_LOOP\n　　INPUT\n　　IF RESULT != 0\n　　　　;!;CLEARLINE 1 \n　　　　;!;REUSELASTLINE 無効ですよ\n　　　　GOTO INPUT_LOOP\n　　ENDIF\n\nのように、GOTO INPUT_LOOPの前にREUSELASTLINEを呼び出すと、\n前の入力が画面から消去され、次の入力は前の入力と同じ行に表示される\nこれによって、無効な入力が繰り返されても、行数が増えず、\n気づいたら選択肢が画面外に…なんて事態は防げる…はず\n\nちなみに@USERXXX系関数の条件分岐の最後に\n（対象は@USERCOM、@USERSHOP、@USERABLUPの3つ）\n\n　　;!;ELSE\n　　　　;!;REUSELASTLINE \n　　ENDIF\n\nとやっておくと…？\n(Emuera専用なら;!;は必要なし) 
CLEARLINE /// CLEARLINE <消す行数>\n指定した行数の文字列を削除します（行の数え方はLINECOUNTと同様です）\n行数はPRINTL等で改行が行われるまでのものを1つの行とします。\nなお、長い文字列が複数行に分割されたものもまとめて1行として扱うので気をつけてください。 
PRINT_IMG /// PRINT_IMG <文字列式>\n行中に指定した画像を表示します。\nHTML_PRINT命令の<img>タグに相当します。 
PRINT_RECT /// PRINT_RECT <数式>\n行中に横幅がフォントサイズの引数％である長方形を表示します。\nSETCOLOR命令によりフォント色と同様に色を変えられます。\nHTML_PRINT命令の<shape type='rect'>タグに相当します。 \n\nPRINT_RECT <数式>, <数式>, <数式>, <数式>\n行中にx,y,横幅,縦幅がそれぞれ引数％である長方形を表示します。\nSETCOLOR命令によりフォント色と同様に色を変えられます。\nHTML_PRINT命令の<shape type='rect'>タグに相当します。 
PRINT_SPACE /// PRINT_SPACE <数式>\nフォントサイズの引数％分だけ何も表示しないスペースを作ります。\nHTML_PRINT命令の<shape type='space'>タグに相当します。 


;表示操作・フォント操作・表示仕様参照
SETCOLOR,RESETCOLOR /// SETCOLOR <R>, <G>, <B>\nSETCOLOR <RGB>\nRESETCOLOR\n文字色を指定した色に変更、適用はRESETCOLORが呼ばれるまで。\n指定方法はRGB形式になります\nSETCOLORで指定した色はRESETCOLORでリセットすることができます\n現在の背景色はGETCOLORで、デフォルトの背景色はGETDEFCOLORで取得することができます。\n1.731以降ではSETCOLORに0xRRGGBB形式で指定できるようになりました。\n\nSETCOLOR 255, 128, 0\nSETCOLOR 0xFF8000\n\nこれはどちらの行も同じ意味になります。 GETCOLOR命令で取得できる値は後者です。 
SETBGCOLOR,RESETBGCOLOR /// SETBGCOLOR <R>, <G>, <B>\nSETBGCOLOR <RGB>\nRESETBGCOLOR\n背景色を指定した色に変更する命令です。\n基本的な仕様はSETCOLOR・RESETCOLORと同様ですが、\n安全のため変更後0.2秒以内に再変更する場合は0.2秒経過まで強制WAITになります。\n現在の背景色はGETBGCOLORで、デフォルトの背景色はGETDEFBGCOLORで取得することができます。 
SETCOLORBYNAME,SETBGCOLORBYNAME /// SETCOLORBYNAME <文字列>\nSETBGCOLORBYNAME <文字列>\n定義済み色名からフォント表示色や背景色を指定する命令です。\n他の仕様はすべてSETCOLOR・SETBGCOLORと同様です。 引数は色名です。定義済み色名についてはKnownColor列挙体 に準拠しておりますので、そちらを参照してください。 
GETCOLOR /// GETCOLOR\n現在使用している文字色コードをRESULT:0に代入します。\n戻り値は16進数で0xRRGGBBとなります。\n例えばオレンジ色(R,G,B) = (255, 128, 0)であれば0xFF8000(10進数で16744448)を返します。\n色と数字の対応はweb colorについて解説しているWebサイトを参考にするとよいでしょう。\n1.731での変更により、SETCOLOR命令もSETCOLOR 0xFF8000のような形式で指定できるようになりました。 
GETDEFCOLOR /// GETDEFCOLOR\n\nコンフィグで指定している文字色コードをRESULT:0に代入します。\n基本的な仕様はGETCOLORと同様です。 
GETBGCOLOR /// GETBGCOLOR\n\n現在使用している背景色コードをRESULT:0に代入します。\n基本的な仕様はGETCOLORと同様です。 
GETDEFBGCOLOR /// GETDEFBGCOLOR\n\nコンフィグで指定している背景色コードをRESULT:0に代入します。\n基本的な仕様はGETCOLORと同様です。 
FONTBOLD,FONTITALIC,FONTREGULAR /// FONTBOLD\nFONTITALIC\nFONTREGULAR\n\n以降の文字を指定したスタイルに変更する\nBOLDとITALICは重複可（太字斜体）\nREGULARを呼ぶと、太字・斜体指定が解除されます 
FONTSTYLE /// FONTSTYLE <数式>\n\n　FONTSTYLE以降の文字を指定したスタイルに変更します。\n　0であれば通常、1なら太字、2なら斜体、4なら打ち消し線、8なら下線が引かれます。\n　これらはビットごとに組み合わせることができます。\n　例えばFONTSTYLE 3なら太字かつ斜体になります。\n　FONTBOLD、FONTITALICは現在のスタイルに太字、斜体スタイルを加えます。\n　FONTREGULARはFONTSTYLE 0と等価です。つまり通常のスタイルに戻します。\n\n　　FONTSTYLE 1 + 2\n　　PRINTL 太字＋斜体\n　　FONTSTYLE 5\n　　PRINTL 太字＋打ち消し\n　　FONTITALIC\n　　PRINTL 太字＋斜体＋打ち消し\n　　FONTSTYLE 0\n　　PRINTL 通常\n<表示結果は実際に試してみてください>\n
GETSTYLE /// GETSTYLE\n\n現在のフォントのスタイル（太字、斜線など）をRESULT:0に代入します。\nこれはSETSTYLE命令で指定した値と同じです。\nSETSTYLE命令が行われていない時は0を返します。 
CHKFONT /// CHKFONT <文字列式>\n\n指定された名前のフォントがインストールされているかどうかを調べます。\nインストールされていれば1、されていなければ0がRESULT:0に代入されます。\n使用例はSETFONT命令を参照してください。 
SETFONT /// SETFONT <文字列式>\n\nSETFONT命令以降の文字列表示に指定された名前のフォントを用います。\n引数を省略、または空文字列を指定した場合、emuera.configに指定された標準のフォントに戻します。\n指定されたフォントがインストールされていない場合、代わりに"Microsoft Sans Serif"が使用されます。\nインストールされていない可能性があるフォントを指定する場合はSETFONTの前にCHKFONT命令を行ってください。\n\n　　PRINTL abc123あいう(標準フォント)\n　　CHKFONT "ＭＳ Ｐゴシック"\n　　IF RESULT\n　　　　SETFONT "ＭＳ Ｐゴシック"\n　　　　PRINTL abc123あいう(ＭＳ Ｐゴシック)\n　　ENDIF\n　　CHKFONT "ＭＳ 明朝"\n　　IF RESULT\n　　　　SETFONT "ＭＳ 明朝"\n　　　　PRINTL abc123あいう(ＭＳ 明朝)\n　　ENDIF\n　　STR:0 = ＭＳ Ｐ明朝\n　　CHKFONT STR:0\n　　IF RESULT\n　　　　SETFONT STR:0\n　　　　PRINTL abc123あいう(ＭＳ Ｐ明朝)\n　　ENDIF\n　　SETFONT
GETFONT /// GETFONT\n\n現在使用しているフォントの名前をRESULTS:0に代入します。\nこれはSETFONT命令で指定した名前と同じです。\nSETFONT命令が行われていない時はemuera.configで指定されている標準のフォントの名前を代入します。 
FORCEKANA /// FORCEKANA <数式>\n\n表示命令のひらがな・カタカナを指定します。\nキーワード"K"を含む各種PRINT系命令で有効になります。\n引数で指定した値により、以下の影響があります。\n\n    0:変換を行わない\n    1:ひらがな→カタカナ\n    2:カタカナ→ひらがな（全角のみ）\n    3:カタカナ→ひらがな（全角・半角両方とも） 
ALIGNMENT /// ALIGNMENT <キーワード>\n\nALIGNMENT以降の行を指定した位置に揃えます。\nキーワードには"LEFT"、"CENTER"、"RIGHT"のいずれかを指定します。\n通常の表示はALIGNMENT LEFTであり、左端に揃えられます。\nALIGNMENT CENTERによりタイトル画面のように中央に揃えることができます。\nALIGNMENTが適用されるのは改行された時点です。\n\n　　ALIGNMENT RIGHT\n　　PRINT あああ\n　　ALIGNMENT CENTER\n　　PRINTL いいい\n　　ALIGNMENT LEFT\n\nこのようにすると、"あああいいい"という文字列が中央揃えで表示されます。\n現在のALIGNMENTはCURRENTALIGNで取得することができます。
CURRENTALIGN /// CURRENTALIGN\n\n現在のALIGNMENTをRESULTS:0に代入します。\n返値はALIGNMENT命令で指定した文字列と同じです（大文字）。\nALIGNMENT命令が行われていない時は初期値のLEFTを返します。
REDRAW /// REDRAW <数式>\n\n描画制御命令です。\n引数に0を指定するとユーザーが入力を必要とするタイミングでのみ描画を行うようにします。\n引数に1を指定すると通常通り、コンフィグの"フレーム毎秒"で指定されたタイミングで描画を行います。\n引数に2を加えると(REDRAW 2やREDRAW 3など)、上記の効果に加え、REDRAW命令を行った瞬間に強制的に描画を行います。\n現在のREDRAW状態（0または1）はCURRENTREDRAWで取得することができます。
CURRENTREDRAW /// CURRENTREDRAW\n\n現在のREDRAW状態をRESULT:0に代入します。\n返値は通常時は1、REDRAW命令を用いて描画を抑制した時は0になります。
PRINTCPERLINE /// PRINTCPERLINE\n\nコンフィグ"PRINTCを並べる数"で指定された数をRESULT:0に代入します。標準は3です。
LINEISEMPTY /// LINEISEMPTY\n\n現在PRINTしている行が空行かどうかを判断する命令です。\nこの命令を実行した時点で「PRINTL 」を行おうとした場合、\nその結果がただの空行になる場合には1を、そうでない場合は0をRESULT:0に代入します。\nPRINTC系で条件に応じたボタンを順次書き連ねる場合に、最後にこの命令を使用することで、\n表示されるボタンがあるかないかを判別し、なければ専用の表示をするといったことが可能です
BARSTR /// BARSTR <変数>, <最大値>, <長さ>\n\n与えられた引数と同一の引数のBAR命令で表示される文字列と同じ物をRESULTS:0に代入します。
MONEYSTR /// MONEYSTR <数値>{, <書式指定子>}\n\n引数で与えられた数値に対して、設定されたお金の単位を付けた文字列をRESULTS:0に代入します。\n単位の前置・後置も自動的に処理します。\n第2引数はTOSTR命令と同様の数値の文字列化における変換書式指定子となります。
SKIPDISP /// SKIPDISP <数値>\n\n以下、私家改造版更新履歴より、\n\nPRINT等の画面出力命令およびWAIT、TWAITなどの命令を無視するフラグを設定する命令SKIPDISP追加\n　書式：SKIPDISP <数値>\n　引数：0 　　無視しないようにする\n　　　　0以外 無視するようにする\n　内容：このフラグを立てると、PRINT等の出力が一切行われなくなる\n　　　　また、このフラグが立ってる間にINPUTおよびINPUTSに達した場合は\n　　　　ユーザーが何をすればいい知る術がないこと、また飛ばせば無限ループに入る可能性が高いため\n　　　　警告文と対処法を明示した上でエラーになるようにしてあります\n　　今一般に使われる口上の実装では口上の非表示が可能な場合、\n　　表示と非表示でコマンドの結果が変わったり、動作が変わってしまう場合がある\n　　そこで、これを立てた上で口上を呼び出せば、表示はされることなくそれ以外の処理が行われるため\n　　表示/非表示で同じ動作を期待できる\n　　INPUT/INPUTSがかぶる場合は上のNOSKIP～ENDNOSKIPで囲んだり、\n　　SKIPDISP 0しておいて、INPUT処理後に再度SKIPDISP 1するなりの対策があります（一応前者推奨）\n　　ちなみに今無視するフラグが立ってるかはISSKIP()式中関数で取得できます\n\nver1.808から、SIF文の直後に置いても動作するようになりました。 なお、SKIPDISPを使用すると引数に関係なくRESULT:0が0にリセットされますが仕様となります。
NOSKIP,ENDNOSKIP /// NOSKIP\nENDNOSKIP\n\n以下、私家改造版更新履歴より、\n\n表示関係無視フラグを無視する区間を指定できるNOSKIP～ENDNOSKIP実装\n　　この2つで囲った区間はSKIPDISP 1の状態でも表示等される\n　　主にINPUTが必要な場合に使用するとよい\n　　また、この命令はSKIPDISPの状態に影響しないので、\n　　SKIPDISPフラグが立ちうる環境下のコード（例えば表示/非表示のある口上関係）では\n　　これを使うと、絶対に表示する必要がある場所をきちんと表示できるようになります
ISSKIP /// ISSKIP\n\nSKIPDISPのフラグが0以外（PRINT等の出力を無視）なら1を、そうでなければ0をRESULT:0に代入します
MOUSESKIP /// MOUSESKIP\n\n右クリックが押されてWAITスキップの状態になっているなら1を、そうでなければ0をRESULT:0に代入します\nマクロ処理時のスキップ中は0を返します\nマクロ処理のスキップと右クリックが競合した場合はマクロを優先し0を返します 


;文字列操作・参照
TOUPPER,TOLOWER,TOHALF,TOFULL /// TOUPPER <文字列式>\nTOLOWER <文字列式>\nTOHALF <文字列式>\nTOFULL <文字列式>\n\n引数の文字列に特定の変換をかけた結果をRESULTS:0に代入します。\nTOUPPERはアルファベットを大文字にした結果を、TOLOWERは小文字化した結果を代入します\nTOHALFは全角文字を半角にしますが、対応する半角文字がない全角文字はそのままです。\nTOFULLは半角文字を全角にします。 
TOSTR /// TOSTR <数式>, <書式指定子>\n\n数値を文字列に変換する命令です。\n変換したい数字を第一引数に、変換の書式を文字列で第二引数に指定します。\n第二引数は省略できますが、省略した場合はPRINTFORMの{}内などと同じように単に文字列になります。\nこの関数は内部でC#のInt64.ToString()関数を呼んでおり、C#と同じ書式指定ができます。第二引数が適切でない場合、エラーになります。\n簡単な書式指定の例は同名の式中で使える関数を確認してください。 書式指定の詳細はC#の数値書式指定文字列について解説しているWebサイトを参考にして下さい。 
TOINT /// TOINT <文字列式>\n\n引数文字列を数値化してRESULT:0に代入します。ただし、半角数字で構成された文字列のみ数値化できます。\n引数を数値として解釈できない場合、0が代入されます。全角数字の場合も同様です。 
STRLEN,STRLENS,STRLENFORM /// STRLEN <文字列>\nSTRLENS <文字列式>\nSTRLENFORM <書式付文字列>\n\n文字列の長さを測定し、RESULT:0に代入します。\n長さはSHIFT-JISでのバイト数です。つまり全角文字を2文字と数えます。\n\n　　STRLEN ABCあいう\n　　PRINTFORML <TEST1> = {RESULT}\n　　STR:0 = ABCあいう\n　　STRLENS STR:0\n　　PRINTFORML <TEST2> = {RESULT}\n　　STRLENFORM abc%STR:0%\n　　PRINTFORML <TEST3> = {RESULT}\n\n　　;STRLENSは文字列式にも対応\n　　STRLENS "abc" + STR:0\n　　PRINTFORML <TEST4> = {RESULT}\n　　WAIT\n　結果\n　<TEST1> = 9\n　<TEST2> = 9\n　<TEST3> = 12\n　<TEST4> = 12\n
STRLENU,STRLENSU,STRLENFORMU /// STRLENU <文字列>\nSTRLENSU <文字列式>\nSTRLENFORMU <書式付文字列>\n\nSTRLEN、STRLENS、STRLENFORMのUnicode版です。違いは全角文字も1文字と数えることです。 
SUBSTRING,SUBSTRINGU /// SUBSTRING <文字列式>, <数式>, <数式>\n\n指定した文字列式の部分文字列をRESULTS:0に代入します。\n開始位置は文字列の最初が0です。元文字列の長さより後を指定した場合、空文字列""が返されます。\n文字数はSHIFT-JISでのバイト数で指定します。つまり全角文字を2文字と数えます。\n文字数に負の値を指定するか、元文字列の終端より後の位置を指定した場合、開始位置から最後までの文字列を返します。\n開始位置または終了位置で文字を切ることができない場合（全角文字の途中を指している場合）、1つ後ろを指定されたと判断されます。\nこのことで指定した文字数よりも1文字分だけ長い文字列が返される場合があるので注意してください。\n\n　　STR:0 = 01234あいうえお\n　　SUBSTRING STR:0, 0, -1\n　　PRINTFORML <TEST1> = %RESULTS:0%\n　　SUBSTRING STR:0, 1, 3\n　　PRINTFORML <TEST2> = %RESULTS:0%\n　　SUBSTRING STR:0, 6, 3\n　　PRINTFORML <TEST3> = %RESULTS:0%\n　　WAIT\n　結果\n　<TEST1> = 01234あいうえお\n　<TEST2> = 123\n　<TEST3> = いう\n\nSUBSTRINGU <文字列式>, <数式>, <数式>\n\nSUBSTRINGのUnicode版です。違いは全角文字も1文字と数えることです。 
STRFIND,STRFINDU /// STRFIND <文字列式>, <文字列式>(, <数式>)\n\n文字列検索命令です。\n第一引数には検索される対象の文字列を文字列式で、\n第二引数には検索する文字列を文字列式で指定します。\nRESULT:0に全角文字を2文字と数え、0から始まるインデックスが代入されます。見つからなかった場合は-1です。\n\n　　STR:0 = abcdefghi\n　　STR:1 = あいうえお\n　　STR:2 = うえ\n　　STRFIND STR:0, "cde"\n　　PRINTFORML <TEST1> = {RESULT:0}\n　　STRFIND STR:1, "いうえ"\n　　PRINTFORML <TEST2> = {RESULT:0}\n　　STRFIND STR:1, STR:2\n　　PRINTFORML <TEST3> = {RESULT:0}\n　　STRFIND STR:1, "か"\n　　PRINTFORML <TEST4> = {RESULT:0}\n;結果\n<TEST1> = 2\n<TEST2> = 2\n<TEST3> = 4\n<TEST4> = -1\n\n1.712以降、STRFIND命令に第3引数が指定できるようにしました。\n第3引数には検索の開始位置を0から始まるインデックスで指定します。\n\n　　STRFIND "abcdeabced","a",3\n\n上の行の結果、RESULTには5が代入されます。\n"a"は0の位置にもありますが、第3引数により検索は3の位置("d")から開始されるので最初に見つかる"a"は5の位置になります。\n\n\nSTRFINDU <検索対象>, <検索する文字列>{, <開始インデックス>}\n\n以下、私家改造版更新履歴より、\n\nSTRFINDのユニコード版STRFINDU実装\n　書式：STRFINDU(<検索対象>, <検索する文字列>{, <開始インデックス>})\n　内容：STRFINDのユニコード版、返り値の文字の位置と開始インデックスがユニコードでのカウントになっている\n
STRCOUNT /// STRCOUNT <検索対象文字列>, <検索文字列>\n\n文字列中の指定部分文字列の数を取得する命令です。ヒットした数をRESULT:0に代入します。\n検索文字列の書式はC#の正規表現の仕様に準じます。 
SPLIT /// SPLIT <文字列式>, <文字列式>, <文字列変数>\n\n第1引数で指定した文字列を、第2引数で指定した文字列を区切りとして分割し、第3引数で指定した文字列配列変数に代入します。\nまた、分割した数をRESULTに代入します。\n第3引数で指定する変数は配列変数でなければなりません。\n\nSPLIT "あい,うえ,,お", ",", LOCALS\n\n上記のスクリプトの結果、LOCALS:0に"あい"、LOCALS:1に"うえ"、LOCALS:2に""（空文字列）、LOCALS:3に"お"、RESULTに4が代入されます。\n分割後の要素数が第3引数に代入可能な要素数を超えた分については代入が行われません\nRESULTには実際の分割数が入れられるのでそちらで判別してください
REPLACE /// REPLACE <置換対象文字列>, <置換対象パターン>, <置換後の文字列>\n\n以下、私家改造版更新履歴より、\n\n文字列置換命令REPLACE実装\n　書式：REPLACE(<置換対象文字列>, <置換対象パターン>, <置換後の文字列>)\n　内容：置換対象文字列を置換対象パターンで検索し、ヒットしたら置換後の文字列で置き換えます。結果はRESULTSに代入されます。\n　　内部処理は思いっきり正規表現です。第２引数はC#の正規表現の仕様に準じて動作します。\n　　そのため、()や[]、$、/.*+等の正規表現で用いられる記号はエスケープ必須となります
ESCAPE /// ESCAPE <文字列>\n\n以下、私家改造版更新履歴より、\n\n文字列を正規表現用にエスケープする式中関数ESCAPEを追加\n　書式：ESCAPE([文字列])\n　内容：文字列が正規表現中で平文となるように、引数中の文字列の正規表現メタ文字をエスケープして返す
UNICODE /// UNICODE <数式>\n\nRESULTS:0に引数の値に対応したunicodeの文字を代入する命令です。\n例えば、以下のスクリプトは白抜きのハートマークを表示します。\nただし、この関数ではサロゲートペアを扱うことはできません。\nまた、フォントが対応していなければ表示できません。\n\nUNICODE 0x2661\nPRINTFORMW %RESULTS%\n\nなお、EmueraのUnicode対応は完全ではないことに注意してください。\n例えばEmueraはサロゲートペアを使用した場合、正確な動作は保証できません。
ENCODETOUNI /// ENCODETOUNI <対象文字列(FORM型文字列)>\n\n以下、私家改造版更新履歴より、\n\n文字列に対してUNICODEのバイトコードを返すENCODETOUNI実装\n　書式：ENCODETOUNI <対象文字列(FORM型文字列)>\n　内容：与えられた文字列をユニコードにエンコードしてそのバイトを数値として返す\n　　　　RESULT:0 　文字数\n　　　　RESULT:1～ バイト数値


;算術
POWER /// POWER <変数>, <数式>, <数式>\n\n　指定した変数に累乗を代入します。\n　例えばPOWER A, X, Y ならば、AにXのY乗が代入されます。\n　演算結果がオーバーフローを起こすとエラーになります。\n\n　　X = 11\n　　Y = 2\n　　POWER A, X, 2\n　　PRINTFORML <TEST1> = {A}\n　　POWER CFLAG:2, X + 1, Y + 1\n　　PRINTFORML <TEST2> = {CFLAG:2}\n　結果(TARGETは適切に設定されているとする)\n　<TEST1> = 121\n　<TEST2> = 1728
ABS /// ABS <数式>\n\n引数の絶対値をRESULT:0に代入します。
SIGN /// SIGN <数式>\n\n引数の符号をRESULT:0に代入します。\n負の値なら-1、0なら0、正の値なら1を代入します。
SQRT /// SQRT <数式>\n\n引数の平方根をRESULT:0に代入します。
GETBIT /// GETBIT <数式>, <数式>\n\n引数の特定のビットを取得し、RESULT:0に代入します。\n第1引数に対象となる数字を、第2引数には取得したいビットの位置を指定します。 第2引数に指定できる値は0～63までで、範囲外の数値を指定するとエラーになります。\n第2引数が定数の場合、例えば5であれば、\n\n　　GETBIT X, 5\n　　RESULT = (X & 1p5) != 0\n\n2つの行は同じ結果になります。
MAX /// MAX <数式>(, <数式>...)\n\n引数の中で最大の数値をRESULT:0に代入します。
MIN /// MIN <数式>(, <数式>...)\n\n引数の中で最小の数値をRESULT:0に代入します。
LIMIT /// LIMIT <数式>, <数式>, <数式>\n\n第一引数の値をRESULT:0に代入します。\nただし、第一引数が第二引数より小さいなら第二引数の値を、第三引数より大きいなら第三引数を返します。\n例えばAに X - Y を代入したいが、代入後の値が0以上100以下であってほしい場合、通常は以下のように書きます。\n\nA = X - Y\nSIF A < 0\n　　A = 0\nSIF A > 100\n　　A = 100\n\nLIMIT命令を使うとこれを二行にまとめることができます。\n\nLIMIT X - Y, 0, 100\nA = RESULT
INRANGE /// INRANGE <数式>, <数式>, <数式>\n\n第一引数の値が第二引数以上かつ第三引数以下であれば1を、第一引数が第二引数より小さい、または第三引数より大きいなら0をRESULT:0に代入します。
SETBIT,CLEARBIT,INVERTBIT /// SETBIT <数値型変数>, <数式>{, <数式>,...}\nCLEARBIT <数値型変数>, <数式>{, <数式>,...}\nINVERTBIT <数値型変数>, <数式>{, <数式>,...}\n\nビット操作関数です。\n第1引数で指定した変数の、第2引数以降で指定した位置のビットを操作します。\nSETBITはビットを1にし、CLEARBITは0にし、INVERTBITは反転させます。\n\n　　SETBIT X, A\n　　CLEARBIT Y, B\n　　INVERTBIT Z, C\n\nの結果は以下と同じです。\n\n　　X |= 1 << A\n　　Y &= ~(1 << B)\n　　Z ^= 1 << C\n\nまた、これらのビット操作関数の書式はGETBIT関数と対応しています。\n"SETBIT X, A" で変更したビットをGETBIT(X, A)で参照することができます。 


;キャラ操作・参照
ADDCHARA,DELCHARA /// ADDCHARA <数式>(, <数式>, <数式>, ...)\nDELCHARA <数式>(, <数式>, <数式>, ...)\n\neramakerからある命令ですが、一度にたくさんのキャラを足したり消せるようになりました
SWAPCHARA /// SWAPCHARA <数式>, <数式>\n\n指定した二人のキャラクタの登録番号を入れ替えます。\n\n　　;MASTERしかいない状態とする\n　　ADDCHARA 10\n　　ADDCHARA 11\n　　PRINTFORML NO:1 = {NO:1}, NO:2 = {NO:2}\n　　SWAPCHARA 1,2\n　　PRINTFORML NO:1 = {NO:1}, NO:2 = {NO:2}\n　結果\n　NO:1 = 10, NO:2 = 11\n　NO:1 = 11, NO:2 = 10
SORTCHARA /// SORTCHARA <キャラクタ変数> {, <FORWARDorBACK>}\n\n任意のキーによる、キャラリストのソート。\nソートキーはNAMEのような文字列変数、NOのような数値型変数、CFLAGのような数値配列変数のいずれでも可能です。\n<キャラクタ変数>は省略することができ、その場合はキャラ番号(NO:XX)でソートされます。\nFORWARDなら昇順、BACKなら降順になります。省略した場合は昇順でソートされます。\nMASTERはソートの対象になりません。\nまた、TARGET:0、ASSI:0は自動で追尾されますので使用後に手動で操作する必要はありません。\nしかしTARGET:1などを使用しているバリアントはこれらを手動で追随させる必要があります。\n\n　　;NOで昇順にソート\n　　SORTCHARA \n　　;NOで降順にソート\n　　SORTCHARA BACK\n　　;CFLAG:2で昇順にソート\n　　SORTCHARA CFLAG:2\n　　;NAMEで降順にソート\n　　SORTCHARA NAME, BACK\n\nなお、TARGET == -1の場合でも、CFLAG:2などの値を実際に参照するわけではないのでエラーにはなりません。
GETCHARA /// GETCHARA <キャラ番号(NO:XXXの方)>\n\n現在所有しているキャラの中にそのキャラがいるかを判定し、いればリスト上での位置を、いなければ-1を返します\nリスト全体から特定のキャラの有無を確認したい場合に使えます
ADDDEFCHARA /// ADDDEFCHARA\n\nゲーム開始時のシステム的なキャラ追加処理を行う命令です。\nchara0*.csvで定義されたキャラと、gamebase.csvで指定された初期キャラを追加します。\n"ADDCHARA 0"はキャラNOが0であるキャラを探して追加しますが、ADDDEFCHARAはcsvの番号でキャラを追加します。\n該当するcsvが存在しない場合、ADDVOIDCHARA同様に空のキャラクタを作成します。\nこれはeramakerの初期化処理を再現するための命令であり、@SYSTEM_TITLE以外では使用できません。
ADDVOIDCHARA /// ADDVOIDCHARA\n\ncsvに依らずにキャラを追加する命令です。\nADDVOIDCHARAで追加されたキャラは全ての変数に0又は""(空文字列)が代入されています。
DELALLCHARA /// DELALLCHARA\n\n登録されている全てのキャラクタを削除します。 以下のスクリプトと同じことです。\n\nREPEAT CHARANUM\n　　DELCHARA 0\nREND
PICKUPCHARA /// PICKUPCHARA <対象キャラ>(, <対象キャラ>, ....)\n\n引数で指定したキャラのみを残し、他のキャラを全て削除する命令です。\nMASTER:0、TARGET:0、ASSI:0などは自動で追随します。命令後手動で設定し直す必要はありません。\n対象キャラに負の値を指定した場合エラーになりますが、MASTER、TARGET、ASSI等を対象に設定し、\nその結果それらの変数の中身が負の値だった場合は、例外でエラーになりません（無視される）。
EXISTCSV /// EXISTCSV <数式>\n\n対応するキャラが定義されているかどうかをチェックしRESULT:0に代入します。\n定義されていれば1、されていなければ0を返します。\nADDCHARA noがエラーにならずに実行できるかどうかを調べることができます。
FINDCHARA,FINDLASTCHARA /// FINDCHARA <キャラクタ変数>, <式>(, <数式>, <数式>)\nFINDLASTCHARA <キャラクタ変数>, <式>(, <数式>, <数式>)\n\nFINDCHARA命令はキャラクタ変数と値を指定し、変数がその値であるキャラクタの登録番号をRESULT:0に返します。\n複数見つかった場合、FINDCHARAは最初にヒットしたキャラを、\nFINDLASTCHARAは最後にヒットしたキャラを返します。見つからなかった場合は-1を返します。\nまた、第3引数を指定することで検索の開始位置を、第4引数を指定することで検索の終了位置を指定できます。\nただし、検索範囲がキャラクタ数の範囲を超える場合はエラーとなります。\n\n　　X = -1\n　　WHILE 1\n　　　　FINDCHARA CFLAG:10, 123, X + 1\n　　　　X = RESULT\n　　　　SIF X < 0\n　　　　　　BREAK\n　　　　PRINTFORML %NAME:X%\n　　WEND
COPYCHARA /// COPYCHARA <数式>, <数式>\n\n第一引数で指定された登録番号のキャラの全てのデータを第二引数で指定された登録番号のキャラにコピーします。
ADDCOPYCHARA /// ADDCOPYCHARA <数式>\n\n引数で指定された登録番号のキャラと同じデータであるキャラを新たに追加します。つまり、ADDCHARAの変種です。


;変数操作・変数参照・CSV参照
VARSIZE /// VARSIZE <変数名>\n\n指定した変数の配列のサイズをRESULT:0に代入します。\n多次元配列変数の場合、一番左の要素から順にRESULT:0, RESULT:1, RESULT:2と代入されます。\n配列のサイズはVariableSize.csvで指定した値です。\n\n　　VARSIZE FLAG\n　　PRINTFORML <TEST1> = {RESULT:0}\n　　VARSIZE SAVESTR\n　　PRINTFORML <TEST2> = {RESULT:0}\n　　VARSIZE TALENT\n　　PRINTFORML <TEST3> = {RESULT:0}\n　　WAIT\n　結果(サイズを変更していない場合)\n　<TEST1> = 10000\n　<TEST2> = 100\n　<TEST3> = 1000\n\n※実際に変数を参照するわけではないので配列外参照が発生することはありません。 上の例ではTARGET == -1の場合でも-1人目のTALENTを参照しようとしてエラー、ということにはなりません。
RESETDATA /// RESETDATA\n\nGLOBALとGLOBALSを除く全ての変数を初期化します。\n具体的には全てのキャラを削除し、全てのローカル変数および全ての通常の変数に0又は空文字列を代入します。\nまた、PALAMLVやSTRなど初期値が設定されている変数については初期値を代入します。
RESETGLOBAL /// RESETGLOBAL\n\nグローバル変数を初期化します。\n具体的にはGLOBALに0を代入し、GLOBALSに空文字列を代入します。
RESET_STAIN /// RESET_STAIN <数式>\n\n第1引数で指定したキャラクタのSTAINを初期化する命令です。 初期値はBEGIN TRAINのときに代入される値と同様で、_replace.csvの「汚れの初期値」で指定できます。
SWAP /// SWAP <変数1>, <変数2>\n\n変数1と変数2の中身を入れ替えます\n交換する2つの変数は同じ型（整数型と整数型、文字列型と文字列型）である必要があります
CSVNAME,CSVCALLNAME,CSVNICKNAME,CSVMASTERNAME /// CSVNAME <数式>\nCSVCALLNAME <数式>\nCSVNICKNAME <数式>\nCSVMASTERNAME <数式>\n\nCSVで定義されたNAME、CALLNAME、NICKNAME、MASTERNAMEを直接呼び出す関数です。\n所有してないキャラの名前とかが欲しいときとかにどうぞ\n第一引数がキャラ番号(NOの方)です。
CSVBASE,CSVCSTR,CSVABL,CSVTALENT,CSVMARK,CSVEXP,CSVRELATION,CSVJUEL,CSVEQUIP,CSVCFLAG /// CSVBASE <数式>, <数式>\nCSVCSTR <数式>, <数式>\nCSVABL <数式>, <数式>\nCSVTALENT <数式>, <数式>\nCSVMARK <数式>, <数式>\nCSVEXP <数式>, <数式>\nCSVRELATION <数式>, <数式>, <数式>\nCSVJUEL <数式>, <数式>\nCSVEQUIP <数式>, <数式>\nCSVCFLAG <数式>, <数式>,\n\nCSVで定義された値を直接呼び出す関数です。\n第一引数がキャラ番号、第二引数が各変数のインデックスです。\nCSVCSTRはRESULTSに文字列を代入し、その他はRESULTに数値を代入します。
GETNUM /// GETNUM <変数名>, <文字列式>\n\n各csvで定義されている名称からその数値を取得し、RESULT:0に代入します。\n例えば、abl.csvで"2,技巧"が定義されていれば、GETNUM ABL, "技巧"の結果、RESULT:0に2が代入されます。\n定義されていない場合は-1になります。\ncsvと変数の対応はEmueraの拡張文法#一般のページの「文字列による配列変数の要素の指定」に準じます。
GETPALAMLV,GETEXPLV /// GETPALAMLV <数式>, <判定するLVの上限>\nGETEXPLV <数式>, <判定するLVの上限>\n\n与えられた値の内容とPALAMLV・EXPLVを比較し、その引数がPALAMLV・EXPLVでどこまで以上かをRESULT:0に代入します。\n第2引数は調査する最大のLVを表します。PALAMLV・EXPLVの値を設定してから使用してください。
FINDELEMENT,FINDLASTELEMENT /// FINDELEMENT <一次元配列変数>, <検索対象(変数と同型)>, <検索初位置>, <検索終位置>, <厳密一致かのフラグ>\nFINDLASTELEMENT <一次元配列変数>, <検索対象(変数と同型)>, <検索初位置>, <検索終位置>, <厳密一致かのフラグ>\n\n配列中の特定範囲から特定の要素の位置を取得する関数です。\n第3・第4引数で指定された配列要素の検索範囲に第2引数で指定されたものと同じ要素があれば、その位置を返します。\n複数ある場合はFINDELEMENTは最初にヒットしたものを、\nFINDLASTELEMENTは最後にヒットしたものを返します。ヒットしない場合は-1を返します。\n検索対象が文字列の場合はREPLACEと同様に正規表現を使えます。\n第5引数は文字列の場合のみ有効で、0であれば文字列の一部が一致でもOKとし、\n0以外であれば文字列と完全に一致した場合のみOKとします。
VARSET /// VARSET <変数名>{, <数式 or 文字列式>, <配列範囲初値>, <配列範囲終値+1>}\n\n指定した変数の配列の指定範囲に第二引数の値を代入します。\n第二引数を省略した場合、0または空文字列が代入されます。\n第三引数以降を省略した場合、配列の全てに代入されます。\n例えば\n\nVARSET FLAG, 0\nVARSET STR, "あああ", 0, 10\nVARSET TA:0:0:0,5678\n\nこの例ではFLAGの要素全てが0になります。\nSTR:0からSTR:9には"あああ"が代入され、TAについても三次元配列の全ての要素に5678が代入されます。\n同じことはERB上でFOR-NEXTループなどを使って行うこともできますが、ループ回数が数十万回程度になると実行時間が無視できなくなります。\nVARSET命令はERB上での代入よりはるかに早く処理を終わらせることができます。\n\nキャラクタ変数をVARSET命令の対象にした場合、指定したキャラの要素のみに代入されます。\n\nVARSET CFLAG:MASTER:0, 0\nVARSET CSTR, ""\n\nこの例ではMASTERのCFLAG:0～999（変更していなければ）が0になりますが、他のキャラのCFLAGは影響を受けません。\nまた、対象を省略した場合は通常通りTARGETとみなされるのでTARGETのCSTRが全て""になります。他のキャラのCSTRは影響を受けません。\n1次元配列および配列型キャラクタ変数以外の、DITEMTYPEやTA等に使用した場合、第三引数以降は無視され配列の全てに代入されます。
CVARSET /// CVARSET <キャラクタ変数>{, <数式>, <式>, <キャラクタ範囲初値>, <キャラクタ範囲終値+1>}\n\n指定した登録キャラクタについてキャラクタ変数の特定要素へ代入する命令です。\n第一引数で指定した変数の第四引数以降で指定した登録キャラクタについて、第二引数で指定した要素へ第三引数で指定した値を代入します。\nNAME、ISASSIなどの一次元配列変数の場合、第二引数は処理に影響しません。そのため第三引数を省略しない場合、適当な値を指定してください。\n第三引数を省略した場合、0又は""(空文字列)が代入されます。\n第二引数も省略した場合、0番目の要素に代入されます。\n第四引数以降を省略した場合、全ての登録キャラクタに代入されます。\n\nCVARSET CFLAG, 10, 123\n\nこのスクリプトは以下と同じことです。\n\nREPEAT CHARANUM\n　　CFLAG:COUNT:10 = 123\nREND
ARRAYSHIFT /// ARRAYSHIFT <対象変数>, <ずらす数>, <ずらしてできた空白領域の初期値>{, <ずらす配列範囲の初値>, <ずらす配列要素の範囲の数>}\n\n以下、私家改造版更新履歴より、\n\n配列をシフトする命令ARRAYSHIFT実装\n　書式：ARRAYSHIFT <対象変数>, <ずらす数>, <ずらしてできた空白領域の初期値>{, <ずらず配列範囲の初値>, <ずらす配列要素の範囲の数>}\n　内容：配列変数を指定した数だけずらす、正の値で添え字の大きい方へ、負の値で小さい方にずらす\n　　　　配列の範囲からはみでた値は掃き捨て、ずらして出来た空白領域は第2引数で指定した値で満たす\n　　　　省略可能な第4および第5引数を使うと一部の範囲のみをずらすことができる\n\n1次元配列および配列型キャラクタ変数のみに対応しています。DITEMTYPEやTA等に使用することはできません。
ARRAYREMOVE /// ARRAYREMOVE <対象変数>, <消す範囲初値>, <消す要素数>\n\n以下、私家改造版更新履歴より、\n\n配列要素を部分削除する命令ARRAYREMOVE実装\n　書式：ARRAYREMOVE <対象変数>, <消す範囲初値>, <消す要素数>\n　内容：配列変数を指定した初期値から要素数分だけ削除し、後ろを値を詰める\n　　　　消す要素数を0以下にすると初期値から後ろ全て消去になります\n\n1次元配列および配列型キャラクタ変数のみに対応しています。DITEMTYPEやTA等に使用することはできません。
ARRAYSORT /// ARRAYSORT <対象変数>{, <ソート方式(FORWARD or BACK)>, <開始インデックス>, <対象要素数>}\n\n以下、私家改造版更新履歴より、\n\n配列変数をソートするARRAYSORT実装\n　書式：ARRAYSORT [対象変数](, [ソート方式(FORWARD or BACK)], [開始インデックス], [対象要素数])\n　内容：開始インデックスから対象要素数個の配列データをソートする\n　　　　FORWARDで昇順、BACKで降順
ARRAYCOPY /// ARRAYCOPY <コピー元変数名>, <コピー先変数名>\n\n以下、私家改造版更新履歴より、\n\n無頓着な配列コピー命令ARRAYCOPY実装\n　書式：ARRAYCOPY <コピー元変数名>, <コピー先変数名>\n　内容：コピー元変数の値をコピー先変数へコピーする\n　　　　型変数は型が同じで次元数が同じである必要がある\n　　　　また、キャラクター変数には非対応\n　　　　要素数が異なる場合はコピーできる分だけコピーする\n\n書式例：ARRAYCOPY "A", "B"
CUPCHECK /// CUPCHECK <登録キャラクター番号>\n\n以下、私家改造版更新履歴より、\n\nCUP、CDOWNに対応するUPCHECKであるCUPCHECK追加\n　書式：CUPCHECK <キャラ>\n　内容：引数で指定したキャラに対するUPCHECKを走らせる、それだけ\n\n当然ですがUP,DOWNの影響はありません。また、UPCHECKでは結果を表示していましたが、CUPCHECKによる結果は表示されません。 


;セーブデータ操作
SAVEDATA /// SAVEDATA <数式>, <文字列式>\n\n<数式>で示される番号のファイルに現在の状態をセーブします。\nSAVEDATA命令は@SAVEINFOを呼び出さないのでPUTFORMでコメントを入れることができません。\n代わりに2つ目の引数の<文字列式>でコメントを指定します。\n(1.704からは文字列変数だけでなく文字列式が使用できます) 以下に例を示します。\n\n　　GETTIME\n　　STR:0 = %RESULTS:0% {DAY+1}日目\n　　SAVEDATA 14, STR:0\n　　SAVEDATA 15, RESULTS:0 + " " + @"{DAY+1}日目"\n　結果(ロード画面)\n　[13] ----\n　[14] 2009年03月28日 00:31:27 1日目\n　[15] 2009年03月28日 00:31:27 1日目\n　[16] ----\n\n上書きの確認などは行わないので必要ならERB側で用意してください。\n既にデータがあるかどうかはCHKDATA命令で調べることができます。\nSAVEDATAは(SAVEGAME命令と違って)スクリプトのどの場所でも呼び出すことができます。
LOADDATA /// LOADDATA <数式>\n\n<数式>で示される番号のファイルのデータをロードします。\nロードに失敗した場合、エラー終了します。\n必ずCHKDATA命令でロード可能かどうかを調べてから実行してください。\nLOADDATAは(LOADGAME命令と違って)スクリプトのどの場所でも呼び出すことができます。
DELDATA /// DELDATA <数式>\n\n<数式>で示される番号のファイルのデータを削除します。\nファイルが存在しなくてもエラーにはなりません。
CHKDATA /// CHKDATA <数式>\n\n<数式>で示される番号のファイルのデータの情報をRESULT:0とRESULTS:0に代入します。\nRESULT:0は以下の値をとります。0の場合のみそのファイルをロードすることができます。\n\n    0 - このファイルはロード可能です。\n    1 - 指定されたファイルは存在しません。\n    2 - ゲームのコードが違います。(gamebase.csvの"コード"の値が違うデータ)\n    3 - バージョンが違います。(gamebase.csvの"バージョン"の値が異なり、許容されるバージョンでもないデータ)\n    4 - 上記以外の問題があるファイルです。 \n\nRESULT:0が0のとき、RESULTS:0にはセーブデータのコメント（@SAVEINFOのPUTFORMで入力した文字列、またはSAVEDATAの第２引数）が代入されます。\nRESULT:0が0以外のとき、RESULTS:0には"セーブデータのバーションが異なります"などのエラーメッセージが代入されます。
SAVENOS /// SAVENOS <数値変数>\n\nコンフィグ"表示するセーブデータ数"で指定された数を取得し指定された数値変数に代入します。標準は20です。\n数値変数を省略することはできません。
SAVEGLOBAL /// SAVEGLOBAL\n\n変数GLOBALとGLOBALSをセーブします。保存先は"global.sav"です。\nERHファイル内でGLOBAL及びSAVEDATAフラグを持つ変数が定義されていればそれもセーブします。
LOADGLOBAL /// LOADGLOBAL\n\nGLOBALとGLOBALSをロードします。保存先は"global.sav"です。\n読み込みに失敗してもエラーにはなりません。\n読み込みに成功するとRESULTに1を、失敗すると0を代入します。\n通常のセーブデータと同様に、gamebase.csvで設定されたコード、バージョンが適切でないファイルはロードできません。\n変数GLOBALの詳細は変数の節を参照してください。
OUTPUTLOG /// OUTPUTLOG\n\n以下、私家改造版更新履歴より、\n\nログ出力命令OUTPUTLOG実装\n　　やり過ぎはディスクの寿命を縮めるのでほどほどに\n\nなお、ログの文字コードはUnicodeです。
SAVECHARA /// SAVECHARA str filename, str memo, int charano{, int charano2, ...}\n\n指定したキャラクタのデータをファイルに保存する命令です。\n第一引数はデータをセーブするファイル名(の一部)を指定します。実際のファイル名は"chara_*.dat"になります。\n第二引数はセーブデータのメモとなる文字列を保存します。後にCHKCHARADATA関数により読むことができます。\n第三引数以降にはセーブしたいキャラの登録番号を指定します。いくつでも可能ですが同一の登録番号を複数回指定することはできません。\ndatフォルダーが存在しない場合、フォルダの作成を試みます。作成に失敗した場合エラーになります。\nまた、第一引数が空文字列である、第一引数にファイル名に使えない文字が含まれるなどの場合エラーになります。
LOADCHARA /// LOADCHARA str filename\n\n第一引数はデータをロードするファイル名(の一部)を指定します。実際のファイル名は"chara_*.dat"になります。\nRESULT:0に、読み取りに失敗した場合は0を、成功した場合は1を代入します。\nLOADVARの前にCHKCHARADATA関数によりファイルの適切さを確認すべきです。\nLOADCHARAはSAVEされているキャラの数だけ新しいキャラを登録します。\nしたがって既存の登録キャラには影響しません。\n何名のキャラが追加されたかを知るにはロード前後でのCHARANUMを比較してください。
CHKCHARADATA /// CHKCHARADATA str filename\n\ndatフォルダ内の"chara_*.dat"で示されるファイル名のデータの情報を返します。\nRESULTにはロード可能な場合は0、何らかの理由により不可能な場合は非0が代入されます。\nまた、ロード可能な場合はRESULTS:0にセーブデータのメモを代入し、不可能な場合はその理由をRESULTS:0に代入します。
FIND_CHARADATA /// FIND_CHARADATA str filename\n\nLOADCHARAの対象となり得るファイルをdatフォルダの中から探索しファイル名(chara_*.datの*の部分)をRESULTSに代入します。\nRESULTにはヒット数（発見されたファイル数）が代入されます。\n引数はchara_*.datの*の部分を指定できます。\n例えばFIND_CHARADATA("*あなた*")であれば、chara_*あなた*.datを探し、chara_001あなた.datやchara_あなたABC.datがヒットします。\n引数を省略した場合、"*"を指定したことになりchara_*.datを探します。\nなお、chara_.dat(*が空文字列)はLOADCHARAで指定できないのでヒットしません。\nヒット数がRESULTSの要素数を超えた場合はエラーにはなりませんが超えた分のファイル名は代入されません。


;日付・時刻取得
GETTIME /// GETTIME\n\nパソコンの現在日時・時刻に関する情報をRESULT:0とRESULTS:0に代入します。\n現在日時が2009年3月28日13時5分23秒678ミリ秒であれば、RESULT:0には"20090328130523678"が代入されます。\nRESULTS:0には"2009年03月28日 13:05:23"が代入されます。\nRESULTS:0は主にセーブデータのコメントに使用することを想定しています。\n年月日について独自の表記をしたい場合はRESULT:0を分解して使用してください。\nなお、RESULT:0の精度は実行する環境にもよりますが、十数～数十ミリ秒程度です。\n（数ミリ秒しか経過していない場合、同じ値が帰ってくることがあります）\nパフォーマンスの測定を目的とする場合は注意してください。
GETMILLISECOND /// GETMILLISECOND\n\n西暦0001年1月1日からの経過時間をミリ秒単位で取得し、RESULT:0に代入します。\nそのまま加減算ができるので経過時間などを調べるにはGETTIMEよりも適しています。\nなお、RESULT:0の精度は実行する環境にもよりますが、十数～数十ミリ秒程度です。\n（数ミリ秒しか経過していない場合、同じ値が帰ってくることがあります）\nパフォーマンスの測定を目的とする場合は注意してください。
GETSECOND /// GETSECOND\n\n西暦0001年1月1日からの経過時間を秒単位で取得し、RESULT:0に代入します。\nそのまま加減算ができるので経過時間などを調べるにはGETTIMEよりも適しています。 


;入力・ウェイト
FORCEWAIT /// FORCEWAIT\n\n右クリック、マクロのスキップでスキップできないWAIT命令です。\nこの命令に達した時点でこれらのスキップ状態は解除されます。
INPUT,INPUTS /// INPUT {<数値>}\nINPUTS {<文字列>}\n\neramakerと同様の命令ですが、引数により空文字列を入力された場合のデフォルト入力値を設定することができます。\n引数を省略し空文字列を入力した場合、従来と同様にINPUTは再入力、INPUTSはRESULTSに空文字列が代入され次の処理へ進みます。
TINPUT,TINPUTS /// TINPUT <数値>, <数値>{, <数値>, <文字列>}\nTINPUTS <数値>, <文字列式>{, <数値>, <文字列>}\n\n制限時間のある入力受付命令です。 1番目の引数は制限時間(ms)ですが、100msより細かい値を設定しても正確な動作はできません。\n2番目の引数は時間切れ時のデフォルトのリターン値になります\n3番目の引数は残り時間を表示するかで0なら非表示、他は表示となります。省略した場合は1（表示）です。\n4番目の引数は時間切れ時に表示される文字列です。空文字列の場合はタイマー表示を消去して次の処理へ移ります。\nなお、4番目の引数を設定した場合、3番目の引数は省略できません。\nまたTINPUTSにおいて、INPUTS同様にマクロ式を用いることができます。\n文字列として()を使用する場合、を用いてエスケープしてください。
TWAIT /// TWAIT <数値>, <数値>\n\n第一引数が制限時間、第二引数が入力受付フラグです。\n制限時間経過するまで動作を停止します\n実際の挙動は入力受付フラグの指定によって変化します\n\n    入力受付フラグ = 0：入力を受け付け、入力がなされると制限時間前でも次に進みます\n    入力受付フラグ ≠ 0：入力を受け付けません（制限時間まで強制的に待たせることができます） 
ONEINPUT,ONEINPUTS /// ONEINPUT {<数値>}\nONEINPUTS {<文字列>}\n\n以下、私家改造版更新履歴より、\n\n一文字限定入力自動処理命令ONEINPUT、ONEINPUTS実装\n　書式：ONEINPUT or ONEINPUTS\n　内容：一文字のみの入力を受け付ける、入力すると自動的に次の処理に移る\n\nペースト等を用いて複数桁の数字（複数の文字）を一度に貼りつけた場合、最初の桁（文字）のみが入力されたものとして処理されます。\nINPUTやINPUTS同様、引数により空文字列を入力された場合のデフォルト入力値を設定することができます。\nただし、ONEINPUTで負の値を指定した場合や、ONEINPUTSで空文字列を指定した場合は、引数は無効となり、引数なしの場合と同じ挙動になります。\nまた、複数桁の数字（複数の文字）を引数とした場合、最初の桁（文字）のみがデフォルト入力値となります。\n引数を省略し空文字列を入力した場合、通常と同様にONEINPUTは再入力、ONEINPUTSはRESULTSに空文字列が代入され次の処理へ進みます。\nONEINPUTSの場合、空文字列のままEnterを押しても空文字列を入力したとみなされます。\nなお、これらの命令を利用した場合にはEmueraのCONFIG設定においてキーボードマクロを使用する設定になっていても、\nうまく働かない現象が起こりますがそれは仕様です。\nまたONEINPUTSにおいて、INPUTS同様にマクロ式を用いることができます。\n文字列として()を使用する場合、を用いてエスケープしてください。
TONEINPUT,TONEINPUTS /// TONEINPUT <数値>, <数値>{, <数値>, <文字列>}\nTONEINPUTS <数値>, <文字列式>{, <数値>, <文字列>}\n\n引数はそれぞれTINPUT、TINPUTSと同じです。\nそれぞれONEINPUTとTINPUT、ONEINPUTSとTINPUTSの性質を併せ持つ入力受付命令です。\nこれらの命令を利用した場合にはEmueraのCONFIG設定においてキーボードマクロを使用する設定になっていても、\nうまく働かない現象が起こりますがそれは仕様です。\nまたTONEINPUTSにおいて、INPUTS同様にマクロ式を用いることができます。\n文字列として()を使用する場合、を用いてエスケープしてください。
WAITANYKEY /// WAITANYKEY\n\nいずれかのキー入力、またはマウスのクリックを待つWAIT命令です。\nWAITのONEINPUT版ともいえます。 


;ループ・分岐構文
FOR,NEXT /// FOR <数値型変数>, <数式>, <数式>{, <数式>}\nNEXT\n\nFOR～NEXTはREPEAT～RENDの機能強化版です。\n第１引数はカウントに使用される変数を表します（REPEATでは常にCOUNT:0）。\n第２引数は変数に最初に代入される値を表します（REPEATでは常に0）。\n第３引数はループが終了される値を表します（REPEATで設定可能な値）。\n第４引数はループごとに加算される値を表します（REPEATでは常に1）。\n\n　　FOR COUNT, 0, X\n　　　　～～\n　　NEXT\n　　REPEAT X\n　　　　～～\n　　REND\n\n上の二つはほぼ同じ動作をします。\nともにX回の繰り返しを行う構文で、ループの途中でCONTINUEやBREAKを使用できます。\n異なる点はカウント用の変数を指定できることと、開始値とステップを変更できることです。\nまた、FOR～NEXTは入れ子にすることができます。\n\n　　FOR Y, 0, 100\n　　　　FOR X, 0, 100\n　　　　　　～～\n　　　　NEXT\n　　NEXT\n\n第１引数である<変数名>に指定できる変数は数値型の変数のみです。キャラクタ変数も使えません。\n第４引数である<ステップ>は省略可能です。省略した場合、1です。\n<ステップ>が正の値のとき、繰り返しのたびに<変数名>の変数に<ステップ>が加算され、第３引数<終了値>を超えたときにループが終了します。\n<ステップ>が負の値のときは、<変数名>の変数が<終了値>より小さくなったときにループが終了します。\n<ステップ>が0であれば無限ループになります。BREAK文が実行されるまで永久に繰り返します。\n各値はループの開始と同時に固定され、ループの途中で変数が変化しても影響を受けません。\n以下の２つは同じ結果になります。\n\n　　;１\n　　X = 10\n　　FOR COUNT:X, 0, X, X/10\n　　　　X = 10000\n　　NEXT\n　　;２\n　　FOR COUNT:10, 0, 10, 10/10\n　　　　X = 10000\n　　NEXT\n\nなお、GOTO等の命令で直接FOR～NEXT内に入った場合、REPEAT～RENDと同様にNEXTの直前まで通常通り実行し、その後NEXTを無視して次の行から処理を続行します。
WHILE,WEND /// WHILE <数式>\nWEND\n\nREPEAT～RENDやFOR～NEXTのような繰り返し構文の一種です。\nWHILEの<数式>が0以外である限りループを繰り返します。\n常に満たし続ける条件を与えると、BREAKで抜けるようになっていない限り無限ループになります\nあまりにループ処理が長いとEmueraが文句を言う場合があります\nなお、GOTO等の命令で直接WHILE～WEND内に入った場合、通常どおりWENDに到達した時点でWHILEへループし、条件を判定します。
DO,LOOP /// DO\nLOOP <数式>\n\nREPEAT～RENDやFOR～NEXTのような繰り返し構文の一種です。\nCのdo～while、VBのdo～loop while構文と同様、LOOPの<数式>が0以外である限り実行をループを繰り返します。\nWHILE～WENDと異なり最低でも1回は実行されることが特徴です。\nなお、DO～LOOP内のCONTINUEした場合にはLOOPの条件を満たしていなければそのままLOOPを抜けます。CONTINUEしてもDO文に戻るとは限らないことに注意してください。\nまた、GOTO等の命令で直接DO～LOOP内に入った場合、通常どおりLOOPに到達した時点で条件を判定し、<数式>が0以外ならDOへループします。
SELECTCASE,CASE,CASEELSE,ENDSELECT /// SELECTCASE <式>\nCASE <CASE条件式>(, <CASE条件式>, <CASE条件式> ……)\nCASEELSE\nENDSELECT\n\nSELECTCASE X\n　　CASE 1\n　　　　PRINTL Xは1です。\n　　CASE 3\n　　　　PRINTL Xは3です。\n　　CASEELSE\n　　　　PRINTL Xは1でも3でもありません。\nENDSELECT\n\nこのスクリプトはXの値によって分岐します。\nSELECTCASE文が実行された時、Xが1であれば"CASE 1"の行に飛び、次のCASEまたはCASEELSEまでの行を実行します。\n同様にXが3であれば"CASE 3"に飛びます。\nXの値に対応するCASE文がない時、CASEELSE文があればそこに飛びます。なければENDSELECTに飛びます。\nCなどのswitch文と異なり、1つのCASEから次のCASEに流れ落ちることはありません。\nまた、BREAK文でENDSELECTに飛ぶことはできません。\nなお、GOTO等の命令で直接SELECTCASE～CASE～CASEELSE～ENDSELECT内に入った場合、IF～ELSEIF～ELSE～ENDIFと同様に\nCASE、CASEELSE、ENDSELECTの直前まで通常通り実行したあとに、ENDSELECTの次の行へ飛び処理を続行します。\n\n以下、詳細はEmuera Wiki参照のこと


;乱数制御
RANDOMIZE,DUMPRAND,INITRAND /// RANDOMIZE <数式>\nDUMPRAND\nINITRAND\n\nRAND:Xで得られる乱数を制御するための命令です。\n\nRANDOMIZE命令は指定した値で乱数を初期化します。\n同じ値で初期化したならば、RANDは必ず同じ結果を返します。\n\nDUMPRANDは現在の乱数の状態をRANDDATA変数に保存します。\nINITRANDはRANDDATA変数に保存したデータを読み出します。\nDUMPRANDを行う前にINITRANDを行ってしまわないように注意してください。\nRANDDATA変数の中身が不適当な場合、RANDが正常に動作しなくなります。\n\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nRANDOMIZE 23478612\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nRANDOMIZE 23478612\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nDUMPRAND\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nINITRAND\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\nINITRAND\nPRINTFORML {RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}/{RAND:100000}\n\n;結果\n92539/49469/48337/15839/48368/1604\n34536/91889/81167/22434/87922/95565\n34536/91889/81167/22434/87922/95565\n68286/10690/68868/82610/90769/60789\n68286/10690/68868/82610/90769/60789\n68286/10690/68868/82610/90769/60789


;デバッグ補助・システムフロー制御
BEGIN /// BEGIN <キーワード>\n\nBEGINはeramakerから存在する命令ですが、キーワードとして新しくFIRSTとTITLEが追加されました。\nBEGIN FIRSTはタイトル画面で"[0]最初からはじめる"を選択した時と同じ効果で、イベント関数@EVENTFIRSTが実行されます。\nBEGIN TITLEはタイトル画面に戻ります。\nどちらも変数の初期化などは行いませんので適宜RESETDATA命令を実行してください。
CALLTRAIN /// CALLTRAIN <コマンド数>\n\n連続コマンド実行命令です。\nあらかじめSELECTCOM:(1～)にコマンド番号を代入しておき、実行するコマンドの数を引数にして実行します。\n\n　　SELECTCOM:1 = XXX\n　　SELECTCOM:2 = YYY\n　　　　　・\n　　　　　・\n　　　　　・\n　　SELECTCOM:N = ZZZ\n\n　　CALLTRAIN (設定したコマンドの数)\n\n通常のコマンド実行と同様にSHOW_STATUSやSHOW_USERCOMも呼び出しますが、TRAINコマンド、USERCOMの表示はされません。\nどうしてもUSERCOMの表示をしたい場合はNOSKIP～ENDNOSKIPを使うと良いでしょう。\nCALLTRAINによる自動実行が終了後、システム関数@CALLTRAINENDが呼び出されます。\nただし、@CALLTRAINENDはイベント関数ではないため多重定義できないことに注意してください。\nなお、コマンドの指定に使うコマンド番号は、ゲーム中の値でなく、TRAIN.CSVで指定した値になります
DOTRAIN /// DOTRAIN <数式>\n\n強制的にTRAINを行う命令です。\n@EVENTTRAIN、@SHOW_STATUS、@SHOW_USERCOM、@USERCOM、@EVENTCOMEND及びそこから呼び出された関数の中でのみ使用可能です。\n引数で指定する番号はtrain.csvで定義した番号に対応しています。\n動作はコマンドが選択された場合と同じで、UP、DOWNなどの変数を初期化し、SELECTCOMに引数を代入し、@EVENTCOMが呼ばれ、@COM{SELECTCOM}が呼ばれ……という流れになります。\n\n引数が0未満であるか、TRAINNAMEの要素数以上の値であればエラーになりますが、それ以外のチェックは行われません。\n引数がtrain.csvで定義されていない数字でも強制的に実行しようとします。\nまた、@COM_ABLEを呼び出さず、強制的に実行されます。\n必要であればDOTRAINの前に以下のようなチェックを行ってください。\n\nSIF ( X < 0 || X >= VARSIZE("TRAINNAME") || TRAINNAME:X == "" )\n　　RETURN\nRESULT = 1\nTRYCALLFORM COM_ABLE{X}\nSIF RESULT == 0\n　　RETURN\nDOTRAIN X\n\n逆にDOTRAINを用いてTRAINのコマンドを独自に実装することもできます。\n例えばtrain.csvを空にしておき、@SHOW_USERCOMで独自に表示し、@USERCOMでDOTRAINを行います。\nあるいはtrain.csvを空にする代わりに全ての@COM_ABLEが0を返すようにしてもよいでしょう。\n@COM_ABLEを変更する代わりに、全ての@COM_ABLEを削除し、_replace.csvの"COM_ABLE初期値"を0にする方法もあります。\n\nなお、CALLTRAINの処理の途中でDOTRAINが行われた場合、CALLTRAINの残りは無効になります。
THROW /// THROW <FORM構文>\n\n強制的にエラーとし、引数に与えた文字列でエラー表示を行う命令です。 


;CALL・JUMP・GOTO系
TRYJUMP,TRYCALL,TRYGOTO /// TRYJUMP <文字列> (, 引数1, 引数2……)\nTRYCALL <文字列> (, 引数1, 引数2……)\nTRYGOTO <文字列>\n\nJUMP、CALL、GOTOと同じですが、指定した関数が存在しなくともエラーになりません。\n指定した関数が存在しない場合は何もしません。\nTRYJUMPとTRYCALLは引数を指定できます。詳しくは関数の「自作関数における引数指定」の項を参照してください。\nなお、TRYGOTOで直接IF～ELSEIF～ELSE～ENDIF内に入った場合、ELSEIF、ELSE、ENDIFの直前まで通常通り実行したあとに、ENDIFの次の行へ飛び処理を続行します。\nまた直接REPEAT～REND内に入った場合、RENDの直前まで通常通り実行し、その後RENDを無視して次の行から処理を続行します。\nこれらの処理はGOTOや他のGOTO系命令と同様の処理です。
JUMPFORM,CALLFORM,GOTOFORM /// JUMPFORM <書式付文字列> (, 引数1, 引数2……)\nCALLFORM <書式付文字列> (, 引数1, 引数2……)\nGOTOFORM <書式付文字列>\n\nJUMP、CALL、GOTOと同じですが、PRINTFORMなどと同じ形式で関数名を指定できます。
TRYJUMPFORM,TRYCALLFORM,TRYGOTOFORM /// TRYJUMPFORM <書式付文字列> (, 引数1, 引数2……)\nTRYCALLFORM <書式付文字列> (, 引数1, 引数2……)\nTRYGOTOFORM <書式付文字列>\n\nJUMP、CALL、GOTOと同じですが、PRINTFORMなどと同じ形式で関数名を指定でき、関数が存在しなくてもエラーになりません。\nTRYJUMPFORMとTRYCALLFORMは引数を指定できます。詳しくは関数の「自作関数における引数指定」の項を参照してください。\nなお、TRYGOTOFORMで直接ループ・分岐構文内に入った場合については「TRYGOTO」やこのページの「ループ・分岐構文」「TRYC系」の項を参照してください。
CALLF,CALLFORMF /// CALLF <文字列> (, 引数1, 引数2……)\nCALLFORMF <書式付文字列> (, 引数1, 引数2……)\n\n以下、私家改造版更新履歴より、\n\n式中関数を返り値無視で呼び出す命令CALLF、CALLFORMF実装\n　書式：CALLF 関数名, 引数1, ....\n　　　　（式中関数ですが、普通の関数の引数書式で呼び出してください）\n　内容：式中関数を通常の関数扱いで呼び出す、返り値は破棄される\n　　疑似SETTERを作りたくてやった、今は反省している\n\n当然だがRESULTやRESULTSは呼んだ式中関数内で操作していない限り、変化しない。
CALLEVENT /// CALLEVENT <文字列>\n\nイベント関数をイベント関数として呼び出します。\n引数を与えることはできません。\nまたイベント関数中やイベント関数から呼び出された関数中で使用することもできません。 


;CALL・JUMP・GOTO系2 (TRYC-CATCH-ENDCATCH)
TRYCJUMP,TRYCCALL,TRYCGOTO,TRYCJUMPFORM,TRYCCALLFORM,TRYCGOTOFORM,CATCH,ENDCATCH /// TRYCJUMP <文字列> (, 引数1, 引数2……)\nTRYCCALL <文字列> (, 引数1, 引数2……)\nTRYCGOTO <文字列>\nTRYCJUMPFORM <書式付文字列> (, 引数1, 引数2……)\nTRYCCALLFORM <書式付文字列> (, 引数1, 引数2……)\nTRYCGOTOFORM <書式付文字列>\nCATCH\nENDCATCH\n\n拡張書式：TRYC系関数呼び出し～CATCH～ENDCATCH\n　(TRYC系はTRY系関数と同様の関数系が用意されてます)\n内容：TRYC系の関数呼び出し時に関数が見つからなかった場合の挙動を制御\n　文法としてはIF～ELSE～ENDIFと同様になりました（違いは関数があった場合の処理がなくてもよいこと）\nそのため、GOTO等の命令で直接TRYC系～CATCH～ENDCATCH内に入った場合、IF～ELSEIF～ELSE～ENDIFと同様に\nCATCH、ENDCATCHの直前まで通常通り実行したあとに、ENDCATCHの次の行へ飛び処理を続行します。\nまた、TRYCGOTO・TRYCGOTOFORMで直接ループ・分岐構文内に入った場合については「TRYGOTO」やこのページの「ループ・分岐構文」の項を参照してください。\n\n　　TRYCCALL UNKNOWN_FUNC ;存在しない関数\n　　　　関数があったとき、関数処理後に行う処理（あれば、なければ省略して直CATCHでOK）\n　　CATCH\n　　　　関数がなかったときに行う処理\n　　ENDCATCH\n\nなお、入れ子可能です。
TRYCALLLIST,TRYJUMPLIST,TRYGOTOLIST,FUNC,ENDFUNC /// TRYCALLLIST\nTRYJUMPLIST\nTRYGOTOLIST\nFUNC <文字列> (, 引数1, 引数2……)\nENDFUNC\n\n複数の関数（ラベル）を指定し、最初に見つかった関数（のみ）を呼び出すための構文です。\nTRYLIST系～ENDFUNC内に上記の文法以外の記述をすることはできません。\nなお、TRYGOTOLISTで直接ループ・分岐構文内に入った場合については「TRYGOTO」やこのページの「ループ・分岐構文」「TRYC系」の項を参照してください。\n以下のように使用します。\n\nTRYCALLLIST\n　　FUNC 関数1\n　　FUNC 関数2\nENDFUNC\n\nFUNCで指定された関数の呼び出しを順に試み、成功すれば呼び出した後ENDFUNCへ、失敗すれば次の行のFUNC（又はENDFUNC）へ移動します。\nこれは以下のスクリプトと同等です。\n\nTRYCCALL 関数1\nCATCH\n　　TRYCCALL 関数2\n　　CATCH\n　　ENDCATCH\nENDCATCH


;RETURN系
RETURN /// RETURN <数式>(, <数式>, <数式>, ...)\n\neramakerからある命令ですが、返り値に定数でない変数や数式も指定できるようになりました。\nまた、複数の返り値に対応しています。\n複数の返り値を指定した場合、先頭からRESULT:0、RESULT:1...という風に代入されます。
RETURNFORM /// RETURNFORM <書式付文字列>(, <書式付文字列>, <書式付文字列>, ...)\n\nRETURNの亜種です。\n引数に指定された書式付文字列を数式として解析し、RETURNを行います。\n例えば、以下のようなことができます。\n\n　　A = 100\n　　CALL TEST\n　　PRINTFORMW RESULT == {RESULT}\n\n@TEST\n　　STR = A * 10\n　　RETURNFORM %STR%\n\nRETURNと異なり、%は剰余演算子ではなく文字列式の開始とみなされるので注意してください。\n\n;OK。Aの下２ケタを返す。\n　　RETURN A % 100\n\n;エラー。%以降を文字列式として読もうとするので。\n　　RETURNFORM A % 100\n\nまた、複数の返り値に対応しています。\n複数の返り値を指定した場合、先頭からRESULT:0、RESULT:1...という風に代入されます。
RETURNF /// RETURNF <式>\n\n#FUNCTIONまたは#FUNCTIONS属性を持つ関数専用の命令です。\n詳細はユーザー定義の式中関数を参照してください。\n複数の返り値には対応していません。 


;DEBUG系
DEBUGPRINT,DEBUGPRINTL,DEBUGPRINTFORM,DEBUGPRINTFORML /// DEBUGPRINT <文字列>\nDEBUGPRINTL <文字列>\nDEBUGPRINTFORM <書式付文字列>\nDEBUGPRINTFORML <書式付文字列>\n\nこれらはそれぞれPRINT命令やPRINTLと同様の動作をします。\n異なる点は出力先がメインコンソールではなくデバッグコンソールである点です。\nまた、SKIPDISP命令の影響を受けず、nを使用することもできません。
DEBUGCLEAR /// DEBUGCLEAR\n\nデバッグコンソールのPRINT内容を全て削除します。
ASSERT /// ASSERT <数式>\n\n引数が真(非0)のとき、何もしません。\n引数が偽(0)の時、エラーを出力してスクリプトの実行を停止します。 


